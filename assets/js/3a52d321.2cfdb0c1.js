"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[202],{7530:e=>{e.exports=JSON.parse('{"functions":[{"name":"addState","desc":"You can add a state to the state machine, which can then be entered and exited with optional lifecycle events.\\n\\n\\t","params":[{"name":"state","desc":"","lua_type":"State<S>"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":95,"path":"lib/init.luau"}},{"name":"removeState","desc":"Removes a state from the internal registry\\n\\n\\t","params":[{"name":"stateName","desc":"","lua_type":"S"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":108,"path":"lib/init.luau"}},{"name":"removeState","desc":"Transitions the Unit from its current state to a new state.\\n\\n**Sequence**:\\n1. Calls old state\'s lifecycle hooks: onBeforeExit \u2192 onExit \u2192 onAfterExit\\n2. Updates the Unit\'s state\\n3. Calls new state\'s lifecycle hooks: onBeforeEnter \u2192 onEnter \u2192 onAfterEnter\\n4. Notifies all subscribers of the transition\\n\\n**Note**: If the new state is not registered, lifecycle hooks are skipped, \\nbut the state value is still updated.\\n\\n\\t","params":[{"name":"newState","desc":"","lua_type":"S"},{"name":"eager?","desc":"true = eager , false = lazy (default)","lua_type":"boolean"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":131,"path":"lib/init.luau"}},{"name":"subscribe","desc":"Registers a callback to be invoked whenever the Unit changes state.\\n\\n**Sequence**:\\n- After every successful state transition, the callback is called with \\n  `(oldState, newState)`.\\n\\n**Note**: Callbacks should be pure functions without side effects that \\nmodify the Unit directly, to avoid unintended recursion.\\n\\n\\t","params":[{"name":"callback","desc":"","lua_type":"TransitionCallback<S>"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":180,"path":"lib/init.luau"}},{"name":"unsubscribe","desc":"Unregisters a previously subscribed transition callback.\\n\\n**Sequence**:\\n- Removes the first matching callback reference from the subscriber list.\\n- If the callback was not registered, nothing happens.\\n\\n**Note**: The callback reference must be the same function object \\nthat was passed to `subscribe`.\\n\\n\\t","params":[{"name":"callback","desc":"function(old: S, new: S) -> ()","lua_type":"TransitionCallback<S>"}],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":200,"path":"lib/init.luau"}},{"name":"getStates","desc":"Returns a list of all registered state names in the Unit.\\n\\n**Note**: The order of states in the returned list is not guaranteed.\\n\\n\\t","params":[],"returns":[{"desc":"array of state names","lua_type":"{ S }"}],"function_type":"method","source":{"line":219,"path":"lib/init.luau"}},{"name":"hasState","desc":"Checks whether a state with the given name is registered in the Unit.\\n\\n\\t","params":[{"name":"stateName","desc":"the state name to check","lua_type":"S"}],"returns":[{"desc":"true if the state is registered, false otherwise","lua_type":"boolean"}],"function_type":"method","source":{"line":235,"path":"lib/init.luau"}},{"name":"reset","desc":"Resets the Unit back to its initial state.\\n\\n**Sequence**:\\n- Calls `changeState(initialState)` internally, \\n  triggering lifecycle hooks and subscriber notifications.\\n\\n\\t","params":[],"returns":[{"desc":"","lua_type":"()"}],"function_type":"method","source":{"line":250,"path":"lib/init.luau"}}],"properties":[],"types":[{"name":"StateCallback","desc":"A function called during a lifecycle event.\\nCan optionally return another function or nil.","lua_type":"() -> ()?","source":{"line":8,"path":"lib/init.luau"}},{"name":"TransitionCallback<S>","desc":"A function called whenever the Unit transitions between states.\\nReceives the previous state and the new state as parameters.","lua_type":"(oldState: S, newState: S) -> ()","source":{"line":14,"path":"lib/init.luau"}},{"name":"State<S>","desc":"","fields":[{"name":"name","lua_type":"S","desc":"The unique name of the state"},{"name":"onEnter","lua_type":"StateCallback?","desc":"Called when entering the state"},{"name":"onExit","lua_type":"StateCallback?","desc":"Called when exiting the state"},{"name":"onBeforeEnter","lua_type":"StateCallback?","desc":"Called immediately before entering the state"},{"name":"onAfterEnter","lua_type":"StateCallback?","desc":"Called immediately after entering the state"},{"name":"onBeforeExit","lua_type":"StateCallback?","desc":"Called immediately before leaving the state"},{"name":"onAfterExit","lua_type":"StateCallback?","desc":"Called immediately after leaving the state"}],"source":{"line":25,"path":"lib/init.luau"}},{"name":"Unit<S>","desc":"","fields":[{"name":"state","lua_type":"S","desc":"The current state of the Unit"},{"name":"addState","lua_type":"(self: Unit<S>, state: State<S>) -> ()","desc":"Register a new state with optional lifecycle callbacks"},{"name":"removeState","lua_type":"(self: Unit<S>, stateName: S) -> ()","desc":"Unregister a state by its name"},{"name":"changeState","lua_type":"(self: Unit<S>, newState: S, eager: boolean?) -> ()","desc":"Transition to a new state (eager = force transition even if same)"},{"name":"subscribe","lua_type":"(self: Unit<S>, callback: TransitionCallback<S>) -> ()","desc":"Register a callback fired on every state transition"},{"name":"unsubscribe","lua_type":"(self: Unit<S>, callback: TransitionCallback<S>) -> ()","desc":"Remove a previously registered transition callback"},{"name":"getStates","lua_type":"(self: Unit<S>) -> { S }","desc":"Returns all registered state names"},{"name":"hasState","lua_type":"(self: Unit<S>, stateName: S) -> boolean","desc":"Returns true if a given state is registered"},{"name":"reset","lua_type":"(self: Unit<S>) -> ()","desc":"Resets the Unit back to its initial state"}],"source":{"line":46,"path":"lib/init.luau"}}],"name":"Unit","desc":"Unit\'s serve as a state machine within Flux. They contain internal tables holding state and subscribers,\\nand also handle functions like subscription callbacks and changing states. ","source":{"line":78,"path":"lib/init.luau"}}')}}]);